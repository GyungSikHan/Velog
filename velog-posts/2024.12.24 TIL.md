<h2 id="c-amp">C++ AMP</h2>
<h3 id="정의">정의</h3>
<p>C++ 프로그래밍 언어를 확장하고 GPU와 같은 데이터 병렬 하드웨어를 활용해 코드 실행을 가속화하는 기술</p>
<h3 id="특징">특징</h3>
<p>병렬처리 최적화 : GPU의 병렬처리 능력을 활용해 대규모 데이터 처리 가속화
프로그래밍 모델 : 다차원 배열, 인데싱, 메모리 전송, 타일링등 지원하는 모델 제공
수학 함수 라이브러리 : 병렬처리에 최적화된 수학 함수 라이브러리 제공
C++ 언어 확장 : 기존 언어에 GPU 프로그래밍을 위한 새로운 키워드와 기능 추가</p>
<h3 id="목적과-장점">목적과 장점</h3>
<p>개발 생산성 확장
이식성 : 다양한 하드웨어에서 실행 가능한 코드를 작성할 수 있도록 설계
접근성 : CUDA나 OpenCL과 같은 복잡한 GPGPU 프로그래밍 기술에 비해 진입 장벽이 낮음
성능 최적화 : GPU의 병렬 처리 능력을 활용해 애플리케이션 성능 크게 향상</p>
<h2 id="코딩-테스트">코딩 테스트</h2>
<hr />
<p>패션왕 신해빈, 팰린드롬 만들기, 주몽 문제를 풀었다
세 문제 다 쉬웠지만 문제를 제대로 안 읽거나 아이디어가 안떠올라 어렵게 풀었다
대부분 구현 문제여서 조금더 단순하게 생각해보고 문제도 꼼꼼히 읽어 다음 코테 문제를 풀어야겠단 반성이 들었다</p>
<h2 id="c-기초플러스">C++ 기초플러스</h2>
<hr />
<p>부트 캠프에서 제공하는 강의를 듣고 생각이 들었다
이미 C++에 대해 공부를 했었기 때문에 강의에서 내용을 정리하여 나중에 보는 것보다 C++ 기초 플러스 책을 읽고 책의 중요하다 생각되는 부분을 정리하여 면접등을 준비하는 것이 나을것 같아 책을 읽고 정리하자는 것이다
그렇다고 강의를 안듣겠다는 것은 아니고 강의를 배속해서 듣고 숙제와 책은 읽는 방식으로 할 것이다</p>
<h3 id="중요한-내용">중요한 내용</h3>
<h4 id="저수준-언어low-level-vs-고수준-언어high-level">저수준 언어(Low Level) VS 고수준 언어(High Level)</h4>
<ul>
<li>저수준 언어<ul>
<li>어셈블리어와 같이 컴퓨터 내부에 사용되는 기계어에 가까운 수준의 언어</li>
</ul>
</li>
<li>고수준 언어<ul>
<li>컴파일러를 사용해 특정 컴퓨터 내부에 맞는 기계어로 변경하는 언어<h3 id="절차적oricedural-언어">절차적(Oricedural) 언어</h3>
프로그래밍에서 데이터보다 알고리즘에 더 치중하는 언어<h3 id="구조적structured-programming-프로그래밍-vs-객체-지향-프로그래밍object-oriented-programming-oop">구조적(Structured Programming) 프로그래밍 VS 객체 지향 프로그래밍(Object Oriented Programming, OOP)</h3>
</li>
</ul>
</li>
<li>구조적 프로그래밍<ul>
<li>몇개의 정형화된 조건을 통해 분기를 사용하도록 제안하는 프로그래밍</li>
<li>장점 : 간결성과 신뢰성, 유지보수 용이</li>
</ul>
</li>
<li>객체 지향 프로그래밍<ul>
<li>데이터를 강조하는 방식으로 해결해야 할 문제를 절차적 접근 방식이 아닌 언어 자체를 해결해야 할 문제에 맞춰 문제의 특성에 맞게 테이터형 자체를 설계하는 프로그래밍</li>
<li>장점<ul>
<li>구조적 프로그램의 간결성과 신뢰성, 유지보수 용이성을 가지면서 규모가 큰 프로젝트에 용이</li>
<li>재활용이 가능한 소스코드를 쉽게 작성 가능</li>
<li>정보를 은닉하고 비인가된 접근으로부터 데이터를 안전하게 보호 가능</li>
<li>이름이 같은 연산자와 함수를 여러벌 정의 가능(오버로딩 Overloading)</li>
<li>상속(Icnheritance)을 이용하여 하나의 클래스로부터 새로운 클래스를 유도<h3 id="객체object">객체(Object)</h3>
</li>
</ul>
</li>
</ul>
</li>
<li>클래스가 그에 맞는 목적으로 설계되는 새로운 데이터형</li>
<li>클래스는 객체를 나타내는 데이터 부분과, 그 데이터를 대상으로 수행할 수 있는 동작 부분으로 정의<h3 id="하양식top-down-설계와-상향식bottom-down-설계">하양식(Top-Down) 설계와 상향식(Bottom-Down) 설계</h3>
</li>
<li>하양식<ul>
<li>구조적 프로그래밍</li>
<li>규모가 큰 프로그램을 작고 다루기 쉬운 단위 작업들로 쪼개 프로그래밍하는 것</li>
<li>C언어에서는 함수(Function)단위 프로그래밍 개발</li>
</ul>
</li>
<li>상향식<ul>
<li>클래스에 해당되는 객체를 만들어 프로그래밍 설계를 함</li>
<li>저수준의 클래스를 설계 후 고수준의 프로그램을 설계하는 것<h3 id="템플릿template">템플릿(Template)</h3>
</li>
</ul>
</li>
<li>특정 데이터형을 지정하지 않고 일반형을 위한 함수를 만들어 그 함수의 여러 유형의 데이터형을 사용할 수 있도록 하는 것<h3 id="프로그래밍-실행-순서">프로그래밍 실행 순서</h3>
<img src="https://velog.velcdn.com/images/gksrudtlr2/post/2470a597-6480-4b0b-8587-3d43d255d6fe/image.png" />
</li>
</ul>
<ol>
<li>소스코드(Source Code) 작성 - .cpp, .h등</li>
<li>소스코드 컴파일시 목적코드(Object Code) 생성 - .o</li>
<li>링커를 통해 목적코드와 실행할 수 있는 프로그램을 만드는 시동코드를 링크 - .lnk</li>
<li>실행파일 생성(executable code) - .exe, .out<h3 id="컴파일이란">컴파일이란?</h3>
</li>
</ol>
<ul>
<li>소스 코드를 컴퓨터 내부에 기계어로 번역해 주는 것</li>
<li>이를 해주는 프로그램을 컴파일러라 함<h3 id="컴파일과-링크">컴파일과 링크</h3>
</li>
<li>컴파일시 생긴 목적파일(.o)을 링커 프로그램에 넘겨 링커가 목적 코드와 라이브러리 코드를 결합하여 실행파일(.exe o.out) 생성</li>
<li>컴파일하는 소스코드가 하나일 시 링커는 더이상 쓸모없는 .o 파일을 삭제하고 실행파일의 이름을 입력하여 프로그램 실행</li>
<li>새로운 프로그램을 컴파일 할 때 마다 메모리 공간의 절약을 위해 새로 생기는 .out이 기존 .out 대체</li>
<li>소스 파일이 여러개인 경우 컴파일러는 .o코드를 삭제하지 않고, 수정한 소스 파일만 컴파일하여 .o 파일에 링크함<h3 id="ide에서-제공하는-옵션">IDE에서 제공하는 옵션</h3>
</li>
<li>Compile : 현재 열려있는 파일에 있는 소스코드를 컴파일함</li>
<li>Build of Make : 프로젝트를 구성하는 모든 소스코드 컴파일. 빈번하게 일어나는 과정으로 변경된 파일만 다시 컴파일함</li>
<li>Link : 컴파일된 소스코드를 필요한 라이브러리와 결합</li>
<li>Run or Execute : 프로그램을 실행. 이전 단계를 거치지 않았다면 이전 단계를 수행후 실행함</li>
<li>Debug : 단계적으로 옵션을 사용해 프로그램 실행</li>
<li>컴파일러는 Debug와 Release 버전을 옵션으로 제공하며 Debug는 부가적 코드가 추가되어 프로그램의 크기가 증가하고 실행 속도가 늦어지지만 세부적 디버깅(Debugging)이 가능하다</li>
</ul>