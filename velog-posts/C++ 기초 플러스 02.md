<h2 id="함수">함수</h2>
<hr />
<h3 id="함수-1">함수</h3>
<ul>
<li>일반적으로 함수는 다른 함수에 의해 호출되는대 함수 머리는 호출 함수와 피 호출 함수의 인터페이스를 나타낸다</li>
<li>함수 이름의 앞부분을 함수 리턴형(Function Return Type)이라고하며 이것은 피 호춯 함수가 호출 함수로 다시 넘겨주는 정보이다</li>
<li>함수 이름 뒤에 있는 괄호 안의 부분을 인자 리스트(Argument List) 또는 매개변수 리스트(Parameter List)라 한다</li>
<li>다른 함수에 의해 호출된 함수는 자신을 호출한 함수에게 값을 리턴할 수 있으며 이 값을 리턴값(Return Value)라 한다</li>
<li>매개변수(Argument)는 함수에서 다른 함수로 전달되는 정보이다<h3 id="리턴값이-있는-함수">리턴값이 있는 함수</h3>
<img alt="" src="https://velog.velcdn.com/images/gksrudtlr2/post/8c732ac1-18f4-4759-818e-42f095e95ead/image.png" /></li>
<li>괄호안에 있는 값(위의 사진)이 함수에 전달되는 정보이다</li>
<li>함수에 전달되는 값을 매개변수(Argument) 또는 매개변수(Parameter)라 한다
<img alt="" src="https://velog.velcdn.com/images/gksrudtlr2/post/521ec992-0829-4e61-93b3-828663b74293/image.png" /></li>
<li>호풀 함수에게 다시 리턴하여 다시 돌려받는 이 값을 함수의 리턴값(return value)라 한다</li>
<li>컴파일러는 그 함수가 어떤 종류의 매개변수를 사용할 것이며 어떤 종류의 리턴값을 리턴하는지 미리 알고있어야 한다</li>
<li>이런 정보가 없다면 컴파일러는 그 리턴값을 어떻게 처리할지 판단할 수 없게 된다</li>
<li>함수 원형(Function Prototype) 구문을 사용하여 이런 정보를 컴파일러에게 전달한다<h3 id="함수-원형을-제공하는-방법">함수 원형을 제공하는 방법</h3>
</li>
<li>함수 원형을 소스 코드 파일에 직접 입력</li>
<li>함수 원형이 들어있는 헤더 파일을 포함시킨다</li>
</ul>
<h2 id="전처리기">전처리기</h2>
<ul>
<li>컴파일하기 전 소스 파일에 대해 미리 어떤 처리를 수행하는 프로그램이다</li>
<li>#으로 시작되는 것을 전처리 지시자(Directive)라 한다</li>
<li>소스 파일을 컴파일할 때 자동으로 실행된다</li>
<li>전처리 지시자는 전처리 지시자 파일 안에 있는 내용을 프로그램과 컴파일러에게 보낸다</li>
<li>프로그램 안에 있는 전처리 지시자 행이 전처리 지시자 파일의 내용으로 대체되며ㅡ 사용자가 작성한 소스 파일은 변경되지 않고 소스 파일과 전처리 지시자 파일의 결합 파일이 컴파일의 다음 단계로 넘어간다</li>
</ul>
<h2 id="using-namespace">using namespace</h2>
<ul>
<li>using 지시자는 뒤에 내용을 사용하겠다는 의미로 뒤에 장에서 설명할 것이다</li>
<li>namespace란 여러 해더파일에서 같은 이름의 함수가 존재할 수 있으므로 어떤 헤더파일의 함수인지 namespace라는 이름으로 사용하는 것이다</li>
<li>예를 들어 std::cout, std::cin등 iostream에서 제공하는 함수라는 의미이고, using namespace std;를 사용하게되면 std라는 키워드 없이 iostream의 함수들을 사용할 수 있게 해준다<h2 id="연산자-오버로딩">연산자 오버로딩</h2>
</li>
<li>연산자 오버로딩에 의해 동일한 연산자 기호가 여러 가지 의미로 가질 수 있다</li>
<li>컴파일러가 전후 관계를 파악하여 그 연산자가 어떤 의미로 사용된 것인지 결정한다<h2 id="c-소스-코드-스타일">C++ 소스 코드 스타일</h2>
</li>
<li>한 행에 하나의 구문을 사용</li>
<li>함수를 여는 중괄호 { 와 닫는 중괄호 } 에 각각 한 행을 할애한다</li>
<li>함수 안에 들어갈 구문들은 중괄호에서 약간 오른쪽으로 들어간 위치에 시작한다</li>
<li>함수 이름과 괄호 사이에는 어떠한 화이트스페이스도 넣지 않는다<h2 id="c-구문">C++ 구문</h2>
</li>
<li>선언 구문(Declaration Statement)<pre><code class="language-C++">  int carrots;</code></pre>
<ul>
<li>저장될 정보의 데이터형과, 거기에 저장될 데이터를 프로그램에서 무슨 이름으로 사용할 것인지 함께 선언한다</li>
<li>변수를 선언하면 컴파일러가 에러를 찾아내 잠재적 버그의 소재를 없앤다</li>
<li>정의 선언 구문이 있다면 컴파일러는 그 변수를 위해 메모리 공간을 대입한다</li>
<li>참조(Reference) 선언 구문은 어딘가에 있는 이미 정의된 변수를 사용할 수 있도록 허용한다</li>
<li>일반적으로 선언이 꼭 정의일 필요는 없으나, 이 예제에서는 정의에 해당한다</li>
</ul>
</li>
<li>대입 구문(Assignment Statement)<pre><code class="language-C++">  int steinway;  
  setinway = 1;</code></pre>
<ul>
<li>대입 구문은 오른쪽에서 왼쪽으로 차례대로 처리된다</li>
</ul>
</li>
<li>선언과 대입<pre><code class="language-C++">  int data = 0;</code></pre>
<ul>
<li>C++에서는 변수를 선언할 때 값도 함께 대입할 수 있는대 이를 초기화(Initialization)이라 한다<h2 id="cout">cout</h2>
</li>
</ul>
</li>
<li>cout은 문자열뿐만 아니라 정수도 출력할 수 있다</li>
<li>정수 25와 문자열 &quot;25&quot;는 완전 다르며 문자열 &quot;25&quot;는 문자 '2'와 문자 '5'를 단순히 붙여 놓은 것이다</li>
<li>프로그램은 내부적으로 문자 '2'와 '5'에 해당하는 코드를 각각 따로 저장한다</li>
<li>문자열 &quot;25&quot;를 출력할때 cout은 그 문자열 안에 있는 문자 '2'와 문자 '5'를 하나씩 꺼내 이어 붙여 출력한다</li>
<li>구로너 정수 25는 온전한 하나의 수이기 때문에, 25라는 수를 하나의 2진수로 저장한다</li>
<li>cout이 int형의 수를 출력하기 전 문자형으로 변환한다</li>
</ul>