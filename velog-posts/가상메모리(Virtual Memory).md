<h2 id="가상메모리란">가상메모리란</h2>
<p>OS에서 사용하는 메모리 관리 기법중 하나로 컴퓨터가 실제 이용가능한 메모리 자원을 추상화하여 이를 사용자들에게 더 큰 메모리로 보이게 만드는것
저장공간인 HDD나 SSD의 일부 영역을 RAM 처럼 사용함으로써 구현됨</p>
<h2 id="주요-개념">주요 개념</h2>
<ol>
<li>논리 주소와 물리 주소<ul>
<li>논리주소(Logical Address) : 프로세스가 사용하는 메모리 주소, 프로그램 실행중 생성되며, 가상 메모리 공간에 해당</li>
<li>물리주소(Physical Address) : 실제 RAM에서의 주소, 논리 주소는 MMU(Memory Management Unit)에 의해 물리 주소로 변환</li>
</ul>
</li>
<li>페이징(Paging)<ul>
<li>가상 메모리를 일정한 크기(페이지)로 나누고, 물리 메모리도 같은 크기(프레임)로 나눔</li>
<li>필요한 페이지만 물리 메모리에 로드하여 메모리를 효율적으로 사용</li>
<li>페이지 테이블 (Page Table)을 사용해 논리 주소와 물리 주소간 매핑을 관리</li>
</ul>
</li>
<li>스왑(Swap)<ul>
<li>물리 메모리가 부족할 때, 사용하지 않는 메모리 페이지를 디스크의 스왑 영역(Swap Space)에 임시로 저장</li>
<li>다시 필요할 때 디스크에서 RAM으로 가져옴. 이는 성능 저하를 유발할 수 있음</li>
</ul>
</li>
<li>세그멘테이션(Segmentation)<ul>
<li>가상 메모리를 논리적인 세그먼트(코드, 데이터, 스택 등)로 나누어 사용하는 방식</li>
<li>각 세그먼트는 크기가 가변적이며, 논리적으로 구분됨</li>
</ul>
</li>
</ol>
<h2 id="가상-메모리-장점">가상 메모리 장점</h2>
<ol>
<li>효율적인 메모리 사용<ul>
<li>모든 프로세스가 전체 메모리를 사용할 필요 없이 필요한 만큼 로드</li>
<li>동일한 프로그램의 코드나 라이브러리를 여러 프로세스가 공유 가능</li>
</ul>
</li>
<li>메모리 보호<ul>
<li>각 프로세스는 독립된 메모리 주소 공간을 가지므로, 다른 프로세스의 메모리를 침범하지 못함</li>
</ul>
</li>
<li>큰 주소 공간 제공<ul>
<li>프로세스는 물리 메모리보다 큰 가상 주소 공간을 사용가능</li>
</ul>
</li>
<li>멀티태스킹 지원<ul>
<li>여러 프로그램이 동시에 실행될 때 메모리를 효율적으로 관리<h2 id="가상-메모리-단점">가상 메모리 단점</h2>
</li>
</ul>
</li>
<li>속도 저하<ul>
<li>스왑 작업이 잦아지면 디스크 접근 시간이 RAM보다 훨씬 느려 성능 저하 발생(스래싱)</li>
</ul>
</li>
<li>오버헤드 증가<ul>
<li>페이지 테이블 관리, 주소 변환 등의 작업이 추가되면서 CPU와 메모리 자원이 소모됨</li>
</ul>
</li>
<li>복잡성 증가<ul>
<li>구현 및 관리가 복잡하며, 효율적인 메모리 관리를 위해 다양한 알고리즘 필요<h2 id="결론">결론</h2>
가상 메모리는 하드웨어와 운영체제의 협력을 통해 구현되며, 제한된 물리 메모리를 효율적으로 사용하고 사용자 및 프로세스에게 넓은 메모리 공간을 제공하는 핵심기술
그러나 디스크 의존성을 줄이고 성능을 유지하기 위해 RAM용량을 적절히 확장하는 것도 중요</li>
</ul>
</li>
</ol>